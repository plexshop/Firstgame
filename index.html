<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Parkour Meet - 3D Demo</title>
<style>
  html,body { height:100%; margin:0; background:#87CEEB; -webkit-tap-highlight-color: transparent; }
  canvas { display:block; width:100%; height:100%; }
  /* UI overlay */
  #ui { position: absolute; inset:0; pointer-events:none; font-family: system-ui, sans-serif; }
  #title {
    position: absolute; top: 12px; left: 12px;
    color: rgba(255,255,255,0.95); font-weight:700; font-size:16px;
    z-index: 40; pointer-events:none; letter-spacing:1px;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }
  #hint {
    pointer-events: none;
    position: absolute; left: 50%; transform: translateX(-50%);
    bottom: 18px; color: rgba(255,255,255,0.86); font-size:13px; z-index: 10;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }
  
  /* Joystick left */
  #joystick {
    pointer-events: auto;
    position: absolute;
    left: 18px; bottom: 28px;
    width: 110px; height: 110px;
    border-radius: 999px; border: 2px solid rgba(0,100,200,0.9);
    z-index: 40; touch-action: none; background: rgba(255,255,255,0.15);
  }
  #stick {
    position: absolute; width: 44px; height: 44px; border-radius: 999px;
    background: rgba(0,100,200,0.95); left: 33px; top: 33px; transition: 0.05s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  /* Jump button right */
  #jumpBtn {
    pointer-events: auto;
    position: absolute;
    right: 18px; bottom: 28px;
    width: 100px; height: 60px;
    border-radius: 12px;
    background: rgba(30, 150, 50, 0.7);
    border: 2px solid rgba(30, 150, 50, 0.9);
    color: white; font-size: 16px; font-weight:700;
    z-index: 40; display:flex; align-items:center; justify-content:center;
    touch-action: none; cursor: pointer;
  }
  #jumpBtn:active { transform: translateY(2px); }

  /* Interaction dialog (center) */
  #dialog {
    pointer-events: auto; position: absolute; left: 50%; top: 50%;
    transform: translate(-50%,-20%); background: rgba(255,255,255,0.9);
    border: 1px solid rgba(0,0,0,0.1); padding: 14px; border-radius: 10px;
    display: none; z-index: 50; width: min(340px,86%); text-align:center; color:#333;
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  }
  .choice {
    display:inline-block; margin:8px 10px 0 10px; pointer-events:auto; 
    background: #4a90e2; color: white; border: none; padding:10px 16px; border-radius:8px;
    font-size:16px; cursor:pointer; transition: background 0.2s;
  }
  .choice:hover { background: #3a7bc8; }
  #speech {
    position: absolute; left: 50%; top: 8%; transform: translateX(-50%);
    background: rgba(255,255,255,0.9); color: #333; padding: 8px 12px; border-radius: 8px;
    display: none; z-index: 50; font-size: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  /* Game over message */
  #gameOver {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 10px;
    display: none; z-index: 60; text-align: center; width: min(300px, 80%);
    box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    pointer-events: auto;
  }
  #restartBtn {
    background: #e74c3c; color: white; border: none; padding: 10px 20px;
    border-radius: 5px; margin-top: 15px; cursor: pointer; font-size: 16px;
  }
</style>
</head>
<body>
  <div id="ui">
    <div id="title">PARKOUR MEET</div>
    <div id="speech"></div>
    <div id="dialog">
      <div style="font-weight:600; margin-bottom:6px;">You reached the person</div>
      <div style="font-size:13px; opacity:0.95;">What do you do?</div>
      <div style="margin-top:10px;">
        <button id="talkBtn" class="choice">Talk</button>
        <button id="leaveBtn" class="choice">Leave</button>
      </div>
    </div>
    
    <div id="gameOver">
      <h2>Game Over</h2>
      <p>You fell to the ground!</p>
      <button id="restartBtn">Restart Game</button>
    </div>

    <div id="joystick"><div id="stick"></div></div>
    <div id="jumpBtn">JUMP</div>
    <div id="hint">Use joystick to move • Jump to cross platforms • Talk when near NPC</div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
  // === Renderer & Scene ===
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87CEEB, 50, 200); // Light blue fog for daytime

  // Camera
  const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 300);
  camera.position.set(0, 4, 8);

  // Lights - Daytime setup
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1);
  sunLight.position.set(10, 20, 5);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 100;
  sunLight.shadow.camera.left = -30;
  sunLight.shadow.camera.right = 30;
  sunLight.shadow.camera.top = 30;
  sunLight.shadow.camera.bottom = -30;
  scene.add(sunLight);

  // Sky background
  scene.background = new THREE.Color(0x87CEEB);

  // Ground - green for daytime
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x7cb342, metalness:0.0, roughness:0.9 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.02;
  ground.receiveShadow = true;
  scene.add(ground);

  // subtle grid for depth
  const grid = new THREE.GridHelper(60, 60, 0x90a4ae, 0x78909c);
  grid.material.opacity = 0.1; grid.material.transparent = true;
  scene.add(grid);

  // === Player (male) - improved character model ===
  const player = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2b3a45 });
  const skinMat = new THREE.MeshStandardMaterial({ color: 0xe6cfb3 });
  const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1a2430 });

  // Torso
  const playerTorso = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.5), bodyMat);
  playerTorso.position.y = 0.7;
  playerTorso.castShadow = true;
  player.add(playerTorso);

  // Head
  const playerHead = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 10), skinMat);
  playerHead.position.set(0, 1.6, 0);
  playerHead.castShadow = true;
  player.add(playerHead);

  // Arms
  const leftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8), skinMat);
  leftArm.position.set(-0.5, 0.8, 0);
  leftArm.rotation.z = Math.PI / 6;
  leftArm.castShadow = true;
  player.add(leftArm);

  const rightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8), skinMat);
  rightArm.position.set(0.5, 0.8, 0);
  rightArm.rotation.z = -Math.PI / 6;
  rightArm.castShadow = true;
  player.add(rightArm);

  // Legs
  const leftLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.9, 8), pantsMat);
  leftLeg.position.set(-0.2, 0.1, 0);
  leftLeg.castShadow = true;
  player.add(leftLeg);

  const rightLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.9, 8), pantsMat);
  rightLeg.position.set(0.2, 0.1, 0);
  rightLeg.castShadow = true;
  player.add(rightLeg);

  // player physics
  let velY = 0;
  const gravity = -28;     // stronger gravity for snappier jumps
  const jumpImpulse = 9.2; // tuned for reachable platforms
  let grounded = false;
  let playerDirection = new THREE.Vector3();
  let gameActive = true;

  // === NPC (female) - improved character model ===
  const npc = new THREE.Group();
  const npcBodyMat = new THREE.MeshStandardMaterial({ color: 0x6a3b5f });
  const npcSkin = new THREE.MeshStandardMaterial({ color: 0xf0d6c0 });
  const npcDressMat = new THREE.MeshStandardMaterial({ color: 0x8a4c7a });

  // Torso
  const npcTorso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.1, 0.4), npcBodyMat);
  npcTorso.position.y = 0.7;
  npcTorso.castShadow = true;
  npc.add(npcTorso);

  // Head
  const npcHead = new THREE.Mesh(new THREE.SphereGeometry(0.23, 12, 10), npcSkin);
  npcHead.position.y = 1.55;
  npcHead.castShadow = true;
  npc.add(npcHead);

  // Hair
  const hair = new THREE.Mesh(new THREE.SphereGeometry(0.28, 12, 10), new THREE.MeshStandardMaterial({ color: 0x1b0f18 }));
  hair.position.set(0, 1.7, -0.1);
  hair.castShadow = true;
  npc.add(hair);

  // Arms
  const npcLeftArm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.7, 8), npcSkin);
  npcLeftArm.position.set(-0.45, 0.8, 0);
  npcLeftArm.rotation.z = Math.PI / 6;
  npcLeftArm.castShadow = true;
  npc.add(npcLeftArm);

  const npcRightArm = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.7, 8), npcSkin);
  npcRightArm.position.set(0.45, 0.8, 0);
  npcRightArm.rotation.z = -Math.PI / 6;
  npcRightArm.castShadow = true;
  npc.add(npcRightArm);

  // Dress/Legs
  const npcDress = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 0.9, 8), npcDressMat);
  npcDress.position.y = 0.1;
  npcDress.castShadow = true;
  npc.add(npcDress);

  // place NPC further away
  npc.position.set(0, 0, -16);
  scene.add(npc);

  // marker above NPC
  const markGeom = new THREE.ConeGeometry(0.13, 0.28, 6);
  const mark = new THREE.Mesh(markGeom, new THREE.MeshBasicMaterial({ color: 0xffcc66 }));
  mark.position.set(0, 2.15, -16);
  mark.rotation.x = Math.PI;
  scene.add(mark);

  // ===== Parkour platforms =====
  // array of platform objects {mesh, minX, maxX, minZ, maxZ, topY}
  const platforms = [];

  function addPlatform(x,z,w=2.2,d=1.6,h=0.3,y=0.18, color=0x4db6ac) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color: color, metalness:0.02, roughness:0.85 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    platforms.push({
      mesh,
      minX: x - w/2,
      maxX: x + w/2,
      minZ: z - d/2,
      maxZ: z + d/2,
      topY: y + h/2
    });
  }

  // Create a sequence of platforms from player to npc
  addPlatform(0, 0.5, 3.5, 2.0, 0.3, 0.18, 0x4db6ac);   // starting safe platform
  addPlatform(0.6, -1.5, 2.2, 1.6, 0.3, 0.18, 0x26a69a);
  addPlatform(-1.1, -4.2, 2.2, 1.6, 0.3, 0.18, 0x009688);
  addPlatform(1.5, -6.9, 2.4, 1.6, 0.3, 0.18, 0x00897b);
  addPlatform(-0.8, -9.3, 2.2, 1.6, 0.3, 0.18, 0x00796b);
  addPlatform(0.7, -11.7, 2.6, 1.6, 0.3, 0.18, 0x00695c);
  addPlatform(-0.3, -14.0, 2.8, 1.8, 0.3, 0.18, 0x004d40);

  // small pillar near NPC
  addPlatform(0, -15.6, 1.2, 1.2, 0.3, 0.18, 0x004d40);

  // Start position - now on the first platform
  const startPos = new THREE.Vector3(0, 0.33, 0.5); // Positioned on the first platform
  const interactionRadius = 1.5;

  // UI elements
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  const jumpBtn = document.getElementById('jumpBtn');
  const gameOverScreen = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');

  let joystickX = 0, joystickY = 0;
  let isTouchingJoystick = false;
  
  joystick.addEventListener('touchstart', e => {
    e.preventDefault();
    isTouchingJoystick = true;
  }, {passive:false});
  
  joystick.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isTouchingJoystick || !gameActive) return;
    
    const rect = joystick.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left - rect.width/2;
    const y = touch.clientY - rect.top - rect.height/2;
    const max = rect.width/2 - 22;
    
    // Calculate distance from center
    const distance = Math.sqrt(x*x + y*y);
    
    if (distance > max) {
      // Normalize to max distance
      joystickX = (x / distance) * max;
      joystickY = (y / distance) * max;
    } else {
      joystickX = x;
      joystickY = y;
    }
    
    stick.style.left = (rect.width/2 - 22 + joystickX) + 'px';
    stick.style.top = (rect.height/2 - 22 + joystickY) + 'px';
  }, {passive:false});
  
  joystick.addEventListener('touchend', e => {
    isTouchingJoystick = false;
    joystickX = 0;
    joystickY = 0;
    stick.style.left = '33px';
    stick.style.top = '33px';
  });

  // Jump button (touch)
  let jumpPressed = false;
  jumpBtn.addEventListener('touchstart', e => { 
    if (!gameActive) return;
    e.preventDefault(); 
    jumpPressed = true; 
  }, {passive:false});
  
  jumpBtn.addEventListener('touchend', e => { 
    e.preventDefault(); 
    jumpPressed = false; 
  }, {passive:false});
  
  // desktop click
  jumpBtn.addEventListener('mousedown', () => {
    if (!gameActive) return;
    jumpPressed = true;
  });
  
  window.addEventListener('mouseup', () => jumpPressed = false);

  // keyboard support
  const keys = {};
  window.addEventListener('keydown', e => { 
    if (!gameActive) return;
    keys[e.key.toLowerCase()] = true; 
    if (e.key === ' ') e.preventDefault(); 
  });
  
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // Dialog & speech UI
  const dialog = document.getElementById('dialog');
  const talkBtn = document.getElementById('talkBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const speech = document.getElementById('speech');
  let inRange = false;

  talkBtn.addEventListener('click', () => {
    speech.style.display = 'block';
    speech.textContent = 'NPC: Hello. Nice to meet you.';
    setTimeout(()=> { speech.style.display = 'none'; }, 2800);
  });

  leaveBtn.addEventListener('click', () => {
    // teleport back to start
    resetGame();
    dialog.style.display = 'none';
    inRange = false;
  });

  // Restart button - FIXED: now properly restarts the game
  restartBtn.addEventListener('click', resetGame);

  // Game reset function
  function resetGame() {
    player.position.copy(startPos);
    velY = 0;
    grounded = false;
    gameActive = true;
    gameOverScreen.style.display = 'none';
    dialog.style.display = 'none';
    inRange = false;
    
    // Reset camera position to behind the player
    camera.position.set(0, 4, 8);
    console.log("Game reset successfully");
  }

  // helper: AABB intersection simple
  function pointInPlatformFeet(px, pz, platform) {
    return (px >= platform.minX - 0.001 && px <= platform.maxX + 0.001 && pz >= platform.minZ - 0.001 && pz <= platform.maxZ + 0.001);
  }

  // Third-person camera variables
  let cameraDistance = 6;
  let cameraHeight = 3;

  // main loop & physics
  let last = performance.now();
  function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    if (!gameActive) {
      renderer.render(scene, camera);
      return;
    }

    // movement input - FIXED: non-inverted controls
    let mvx = 0, mvz = 0;
    
    // Joystick input (normalized) - FIXED: proper direction
    if (Math.abs(joystickX) > 2 || Math.abs(joystickY) > 2) {
      mvx += joystickX / 80;  // Left/right
      mvz += joystickY / 80;  // Forward/backward (NOT inverted)
    }
    
    // Keyboard input
    if (keys['w'] || keys['arrowup']) mvz -= 0.15;
    if (keys['s'] || keys['arrowdown']) mvz += 0.15;
    if (keys['a'] || keys['arrowleft']) mvx -= 0.15;
    if (keys['d'] || keys['arrowright']) mvx += 0.15;

    // Apply movement directly (world space) - SIMPLIFIED
    player.position.x += mvx * dt * 10;
    player.position.z += mvz * dt * 10;

    // Update player rotation based on movement direction
    if (mvx !== 0 || mvz !== 0) {
      player.rotation.y = Math.atan2(mvx, mvz);
    }

    // ----- Vertical physics -----
    // ground/platform collision detection:
    const footX = player.position.x;
    const footZ = player.position.z;
    let surfaceY = -Infinity; // highest surface under the player
    
    // check platforms
    for (const p of platforms) {
      if (pointInPlatformFeet(footX, footZ, p)) {
        if (p.topY > surfaceY) surfaceY = p.topY;
      }
    }
    
    // ground plane at y = 0
    if (0 > surfaceY) surfaceY = 0;

    // apply gravity
    velY += gravity * dt;
    player.position.y += velY * dt;

    // simple collision response: if player is below surface (a little threshold), snap up
    if (player.position.y <= surfaceY + 0.001) {
      player.position.y = surfaceY;
      velY = 0;
      grounded = true;
      
      // Check if player touched the ground (not a platform)
      if (surfaceY === 0) {
        // Game over - player touched the ground
        gameActive = false;
        gameOverScreen.style.display = 'block';
      }
    } else {
      grounded = false;
    }

    // jump action (space or jump button)
    const wantJump = jumpPressed || keys[' '];
    if (wantJump && grounded) {
      velY = jumpImpulse;
      grounded = false;
    }

    // npc bob & slight animation
    npc.rotation.y = Math.sin(now * 0.0008) * 0.02;
    npc.position.x = 0; // keep npc x stable
    npc.position.z = -16; // ensure stays at spot

    // mark rotation
    mark.rotation.y += 0.02;

    // Third-person camera - FIXED: always stays behind the player
    const targetCameraPosition = new THREE.Vector3();
    targetCameraPosition.copy(player.position);
    
    // Calculate camera offset based on player's rotation - FIXED: negative values for behind
    const cameraOffset = new THREE.Vector3(
      -Math.sin(player.rotation.y) * cameraDistance,
      cameraHeight,
      -Math.cos(player.rotation.y) * cameraDistance
    );
    
    targetCameraPosition.add(cameraOffset);
    
    // Smooth camera movement
    camera.position.lerp(targetCameraPosition, 0.1);
    camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);

    // check distance for interaction with npc
    const dx = player.position.x - npc.position.x;
    const dz = player.position.z - npc.position.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    if (dist <= interactionRadius && !inRange) {
      inRange = true;
      dialog.style.display = 'block';
    } else if (dist > interactionRadius && inRange) {
      inRange = false;
      dialog.style.display = 'none';
      speech.style.display = 'none';
    }

    // Render
    renderer.render(scene, camera);
  }
  
  // Enable shadows
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  // Set player position on the first platform
  player.position.copy(startPos);
  scene.add(player);
  
  animate(0);

  // Resize handling
  window.addEventListener('resize', () => {
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
  });

  </script>
</body>
      </html>
