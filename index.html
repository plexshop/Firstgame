<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Parkour Meet - 3D Demo</title>
<style>
  html,body { height:100%; margin:0; background:#87CEEB; -webkit-tap-highlight-color: transparent; }
  canvas { display:block; width:100%; height:100%; }
  /* UI overlay */
  #ui { position: absolute; inset:0; pointer-events:none; font-family: system-ui, sans-serif; }
  #title {
    position: absolute; top: 12px; left: 12px;
    color: rgba(255,255,255,0.95); font-weight:700; font-size:16px;
    z-index: 40; pointer-events:none; letter-spacing:1px;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }
  #hint {
    pointer-events: none;
    position: absolute; left: 50%; transform: translateX(-50%);
    bottom: 18px; color: rgba(255,255,255,0.86); font-size:13px; z-index: 10;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }
  
  /* Joystick left */
  #joystick {
    pointer-events: auto;
    position: absolute;
    left: 18px; bottom: 28px;
    width: 110px; height: 110px;
    border-radius: 999px; border: 2px solid rgba(0,100,200,0.9);
    z-index: 40; touch-action: none; background: rgba(255,255,255,0.15);
  }
  #stick {
    position: absolute; width: 44px; height: 44px; border-radius: 999px;
    background: rgba(0,100,200,0.95); left: 33px; top: 33px; transition: 0.05s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }

  /* Jump button right */
  #jumpBtn {
    pointer-events: auto;
    position: absolute;
    right: 18px; bottom: 28px;
    width: 100px; height: 60px;
    border-radius: 12px;
    background: rgba(30, 150, 50, 0.7);
    border: 2px solid rgba(30, 150, 50, 0.9);
    color: white; font-size: 16px; font-weight:700;
    z-index: 40; display:flex; align-items:center; justify-content:center;
    touch-action: none; cursor: pointer;
  }
  #jumpBtn:active { transform: translateY(2px); }

  /* Interaction dialog (center) */
  #dialog {
    pointer-events: auto; position: absolute; left: 50%; top: 50%;
    transform: translate(-50%,-20%); background: rgba(255,255,255,0.9);
    border: 1px solid rgba(0,0,0,0.1); padding: 14px; border-radius: 10px;
    display: none; z-index: 50; width: min(340px,86%); text-align:center; color:#333;
    box-shadow: 0 8px 20px rgba(0,0,0,0.2);
  }
  .choice {
    display:inline-block; margin:8px 10px 0 10px; pointer-events:auto; 
    background: #4a90e2; color: white; border: none; padding:10px 16px; border-radius:8px;
    font-size:16px; cursor:pointer; transition: background 0.2s;
  }
  .choice:hover { background: #3a7bc8; }
  #speech {
    position: absolute; left: 50%; top: 8%; transform: translateX(-50%);
    background: rgba(255,255,255,0.9); color: #333; padding: 8px 12px; border-radius: 8px;
    display: none; z-index: 50; font-size: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }
  
  /* Game over message */
  #gameOver {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 10px;
    display: none; z-index: 60; text-align: center; width: min(300px, 80%);
    box-shadow: 0 8px 25px rgba(0,0,0,0.5);
    pointer-events: auto;
  }
  #restartBtn {
    background: #e74c3c; color: white; border: none; padding: 10px 20px;
    border-radius: 5px; margin-top: 15px; cursor: pointer; font-size: 16px;
  }
</style>
</head>
<body>
  <div id="ui">
    <div id="title">PARKOUR MEET</div>
    <div id="speech"></div>
    <div id="dialog">
      <div style="font-weight:600; margin-bottom:6px;">You reached the person</div>
      <div style="font-size:13px; opacity:0.95;">What do you do?</div>
      <div style="margin-top:10px;">
        <button id="talkBtn" class="choice">Talk</button>
        <button id="leaveBtn" class="choice">Leave</button>
      </div>
    </div>
    
    <div id="gameOver">
      <h2>Game Over</h2>
      <p>You fell to the ground!</p>
      <button id="restartBtn">Restart Game</button>
    </div>

    <div id="joystick"><div id="stick"></div></div>
    <div id="jumpBtn">JUMP</div>
    <div id="hint">Use joystick to move • Jump to cross platforms • Talk when near NPC</div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
  // === Renderer & Scene ===
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87CEEB, 50, 200); // Light blue fog for daytime

  // Camera
  const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 300);
  camera.position.set(0, 4, 8);

  // Lights - Daytime setup
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambientLight);

  const sunLight = new THREE.DirectionalLight(0xffffff, 1);
  sunLight.position.set(10, 20, 5);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.camera.near = 0.5;
  sunLight.shadow.camera.far = 100;
  sunLight.shadow.camera.left = -30;
  sunLight.shadow.camera.right = 30;
  sunLight.shadow.camera.top = 30;
  sunLight.shadow.camera.bottom = -30;
  scene.add(sunLight);

  // Sky background
  scene.background = new THREE.Color(0x87CEEB);

  // Ground - green for daytime
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x7cb342, metalness:0.0, roughness:0.9 });
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(160, 160), groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.02;
  ground.receiveShadow = true;
  scene.add(ground);

  // subtle grid for depth
  const grid = new THREE.GridHelper(60, 60, 0x90a4ae, 0x78909c);
  grid.material.opacity = 0.1; grid.material.transparent = true;
  scene.add(grid);

  // === Player (male) - improved character model with perfect positioning ===
  const player = new THREE.Group();
  const bodyMat = new THREE.MeshStandardMaterial({ color: 0x2b3a45 });
  const skinMat = new THREE.MeshStandardMaterial({ color: 0xe6cfb3 });
  const pantsMat = new THREE.MeshStandardMaterial({ color: 0x1a2430 });
  const shirtMat = new THREE.MeshStandardMaterial({ color: 0x3a5675 });

  // Torso - slim human-like shape
  const torsoGeom = new THREE.CylinderGeometry(0.3, 0.35, 1.2, 8);
  const playerTorso = new THREE.Mesh(torsoGeom, shirtMat);
  playerTorso.position.y = 0.7;
  playerTorso.castShadow = true;
  player.add(playerTorso);

  // Head - more detailed
  const headGeom = new THREE.SphereGeometry(0.25, 16, 16);
  const playerHead = new THREE.Mesh(headGeom, skinMat);
  playerHead.position.set(0, 1.55, 0);
  playerHead.castShadow = true;
  player.add(playerHead);

  // Arms - sticking out from shoulders properly
  const armGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.8, 8);
  
  // Left arm - properly positioned to stick out from shoulder
  const leftArm = new THREE.Mesh(armGeom, skinMat);
  leftArm.position.set(-0.4, 0.85, 0); // Further from body
  leftArm.rotation.z = 0; // Straight down
  leftArm.castShadow = true;
  player.add(leftArm);

  // Right arm - properly positioned to stick out from shoulder
  const rightArm = new THREE.Mesh(armGeom, skinMat);
  rightArm.position.set(0.4, 0.85, 0); // Further from body
  rightArm.rotation.z = 0; // Straight down
  rightArm.castShadow = true;
  player.add(rightArm);

  // Legs - perfectly positioned with no floating
  const legGeom = new THREE.CylinderGeometry(0.08, 0.08, 0.9, 8);
  
  // Left leg - perfectly positioned with no floating
  const leftLeg = new THREE.Mesh(legGeom, pantsMat);
  leftLeg.position.set(-0.12, -0.15, 0); // Lowered to prevent floating
  leftLeg.castShadow = true;
  player.add(leftLeg);

  // Right leg - perfectly positioned with no floating
  const rightLeg = new THREE.Mesh(legGeom, pantsMat);
  rightLeg.position.set(0.12, -0.15, 0); // Lowered to prevent floating
  rightLeg.castShadow = true;
  player.add(rightLeg);

  // Store limb references for animation
  const playerLimbs = {
    leftArm,
    rightArm,
    leftLeg,
    rightLeg
  };

  // Player physics constants
  const playerHeight = 1.7; // Adjusted for perfect positioning
  const playerRadius = 0.2;

  // player physics
  let velY = 0;
  const gravity = -28;
  const jumpImpulse = 9.2;
  let grounded = false;
  let playerDirection = new THREE.Vector3();
  let gameActive = true;
  let isMoving = false;

  // === NPC (female) - improved character model with perfect positioning ===
  const npc = new THREE.Group();
  const npcBodyMat = new THREE.MeshStandardMaterial({ color: 0x6a3b5f });
  const npcSkin = new THREE.MeshStandardMaterial({ color: 0xf0d6c0 });
  const npcDressMat = new THREE.MeshStandardMaterial({ color: 0x8a4c7a });
  const npcHairMat = new THREE.MeshStandardMaterial({ color: 0x1b0f18 });

  // Torso - slim human-like shape
  const npcTorsoGeom = new THREE.CylinderGeometry(0.25, 0.3, 1.1, 8);
  const npcTorso = new THREE.Mesh(npcTorsoGeom, npcBodyMat);
  npcTorso.position.y = 0.65;
  npcTorso.castShadow = true;
  npc.add(npcTorso);

  // Head - more detailed
  const npcHeadGeom = new THREE.SphereGeometry(0.22, 16, 16);
  const npcHead = new THREE.Mesh(npcHeadGeom, npcSkin);
  npcHead.position.y = 1.5;
  npcHead.castShadow = true;
  npc.add(npcHead);

  // Hair - more detailed
  const hairGeom = new THREE.SphereGeometry(0.26, 16, 16);
  const hair = new THREE.Mesh(hairGeom, npcHairMat);
  hair.position.set(0, 1.65, -0.1);
  hair.scale.set(1, 0.7, 1.2);
  hair.castShadow = true;
  npc.add(hair);

  // Arms - sticking out from shoulders properly
  const npcArmGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 8);
  
  // Left arm - properly positioned to stick out from shoulder
  const npcLeftArm = new THREE.Mesh(npcArmGeom, npcSkin);
  npcLeftArm.position.set(-0.3, 0.8, 0);
  npcLeftArm.rotation.z = 0; // Straight down
  npcLeftArm.castShadow = true;
  npc.add(npcLeftArm);

  // Right arm - properly positioned to stick out from shoulder
  const npcRightArm = new THREE.Mesh(npcArmGeom, npcSkin);
  npcRightArm.position.set(0.3, 0.8, 0);
  npcRightArm.rotation.z = 0; // Straight down
  npcRightArm.castShadow = true;
  npc.add(npcRightArm);

  // Dress - perfectly positioned
  const npcDressGeom = new THREE.CylinderGeometry(0.25, 0.35, 0.8, 8);
  const npcDress = new THREE.Mesh(npcDressGeom, npcDressMat);
  npcDress.position.y = 0.2; // Perfectly positioned
  npcDress.castShadow = true;
  npc.add(npcDress);

  // Legs for NPC (visible under dress) - no floating
  const npcLegGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.5, 8);
  const npcLeftLeg = new THREE.Mesh(npcLegGeom, npcSkin);
  npcLeftLeg.position.set(-0.08, -0.1, 0); // Lowered to prevent floating
  npcLeftLeg.castShadow = true;
  npc.add(npcLeftLeg);

  const npcRightLeg = new THREE.Mesh(npcLegGeom, npcSkin);
  npcRightLeg.position.set(0.08, -0.1, 0); // Lowered to prevent floating
  npcRightLeg.castShadow = true;
  npc.add(npcRightLeg);

  

  // ===== Parkour platforms =====
  const platforms = [];

  function addPlatform(x,z,w=2.2,d=1.6,h=0.3,y=0.18, color=0x4db6ac) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color: color, metalness:0.02, roughness:0.85 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    platforms.push({
      mesh,
      minX: x - w/2,
      maxX: x + w/2,
      minZ: z - d/2,
      maxZ: z + d/2,
      topY: y + h/2
    });
  }

  // Create a sequence of platforms from player to npc
  addPlatform(0, 0.5, 3.5, 2.0, 0.3, 0.18, 0x4db6ac);
  addPlatform(0.6, -1.5, 2.2, 1.6, 0.3, 0.18, 0x26a69a);
  addPlatform(-1.1, -4.2, 2.2, 1.6, 0.3, 0.18, 0x009688);
  addPlatform(1.5, -6.9, 2.4, 1.6, 0.3, 0.18, 0x00897b);
  addPlatform(-0.8, -9.3, 2.2, 1.6, 0.3, 0.18, 0x00796b);
  addPlatform(0.7, -11.7, 2.6, 1.6, 0.3, 0.18, 0x00695c);
  addPlatform(-0.3, -14.0, 2.8, 1.8, 0.3, 0.18, 0x004d40);

  // small pillar near NPC
  addPlatform(0, -15.6, 1.2, 1.2, 0.3, 0.18, 0x004d40);

  // Start position - perfectly positioned on first platform
  const startPos = new THREE.Vector3(0, 0.4, 0.5);
  const interactionRadius = 1.5;

  // UI elements
  const joystick = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  const jumpBtn = document.getElementById('jumpBtn');
  const gameOverScreen = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');

  let joystickX = 0, joystickY = 0;
  let isTouchingJoystick = false;
  
  joystick.addEventListener('touchstart', e => {
    e.preventDefault();
    isTouchingJoystick = true;
  }, {passive:false});
  
  joystick.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!isTouchingJoystick || !gameActive) return;
    
    const rect = joystick.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left - rect.width/2;
    const y = touch.clientY - rect.top - rect.height/2;
    const max = rect.width/2 - 22;
    
    const distance = Math.sqrt(x*x + y*y);
    
    if (distance > max) {
      joystickX = (x / distance) * max;
      joystickY = (y / distance) * max;
    } else {
      joystickX = x;
      joystickY = y;
    }
    
    stick.style.left = (rect.width/2 - 22 + joystickX) + 'px';
    stick.style.top = (rect.height/2 - 22 + joystickY) + 'px';
  }, {passive:false});
  
  joystick.addEventListener('touchend', e => {
    isTouchingJoystick = false;
    joystickX = 0;
    joystickY = 0;
    stick.style.left = '33px';
    stick.style.top = '33px';
  });

  // Jump button (touch)
  let jumpPressed = false;
  jumpBtn.addEventListener('touchstart', e => { 
    if (!gameActive) return;
    e.preventDefault(); 
    jumpPressed = true; 
  }, {passive:false});
  
  jumpBtn.addEventListener('touchend', e => { 
    e.preventDefault(); 
    jumpPressed = false; 
  }, {passive:false});
  
  // desktop click
  jumpBtn.addEventListener('mousedown', () => {
    if (!gameActive) return;
    jumpPressed = true;
  });
  
  window.addEventListener('mouseup', () => jumpPressed = false);

  // keyboard support
  const keys = {};
  window.addEventListener('keydown', e => { 
    if (!gameActive) return;
    keys[e.key.toLowerCase()] = true; 
    if (e.key === ' ') e.preventDefault(); 
  });
  
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  // Dialog & speech UI
  const dialog = document.getElementById('dialog');
  const talkBtn = document.getElementById('talkBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const speech = document.getElementById('speech');
  let inRange = false;

  talkBtn.addEventListener('click', () => {
    speech.style.display = 'block';
    speech.textContent = 'NPC: Hello. Nice to meet you.';
    setTimeout(()=> { speech.style.display = 'none'; }, 2800);
  });

  leaveBtn.addEventListener('click', () => {
    resetGame();
    dialog.style.display = 'none';
    inRange = false;
  });

  // Restart button
  restartBtn.addEventListener('click', resetGame);

  // Game reset function
  function resetGame() {
    player.position.copy(startPos);
    velY = 0;
    grounded = false;
    gameActive = true;
    gameOverScreen.style.display = 'none';
    dialog.style.display = 'none';
    inRange = false;
    camera.position.set(0, 4, 8);
  }

  // IMPROVED: Better collision detection system
  function checkPlatformCollision() {
    const playerFeetY = player.position.y - (playerHeight / 2);
    let highestSurface = -Infinity;
    let onPlatform = false;
    
    for (const platform of platforms) {
      if (player.position.x >= platform.minX && player.position.x <= platform.maxX &&
          player.position.z >= platform.minZ && player.position.z <= platform.maxZ) {
        
        if (playerFeetY <= platform.topY + 0.1) {
          if (platform.topY > highestSurface) {
            highestSurface = platform.topY;
            onPlatform = true;
          }
        }
      }
    }
    
    if (playerFeetY <= 0.1 && !onPlatform) {
      highestSurface = 0;
      onPlatform = true;
    }
    
    return {
      onPlatform,
      surfaceY: highestSurface
    };
  }

  // IMPROVED: Better animations with Roblox-style arm movement
  function updatePlayerAnimation(time, isMoving) {
    if (!isMoving) {
      // Reset to idle position - arms parallel to body
      playerLimbs.leftArm.rotation.x = 0;
      playerLimbs.rightArm.rotation.x = 0;
      playerLimbs.leftLeg.rotation.x = 0;
      playerLimbs.rightLeg.rotation.x = 0;
      return;
    }
    
    // Walking animation - Roblox style
    const walkSpeed = 12;
    const armSwing = Math.sin(time * walkSpeed) * 0.3;
    const legSwing = Math.sin(time * walkSpeed) * 0.4;
    
    // Arm animation - swing forward/backward like Roblox
    playerLimbs.leftArm.rotation.x = -armSwing;
    playerLimbs.rightArm.rotation.x = armSwing;
    
    // Leg animation - natural walking motion
    playerLimbs.leftLeg.rotation.x = legSwing;
    playerLimbs.rightLeg.rotation.x = -legSwing;
  }

  // Third-person camera variables
  let cameraDistance = 6;
  let cameraHeight = 3;

  // main loop & physics
  let last = performance.now();
  function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    if (!gameActive) {
      renderer.render(scene, camera);
      return;
    }

    // movement input
    let mvx = 0, mvz = 0;
    
    if (Math.abs(joystickX) > 2 || Math.abs(joystickY) > 2) {
      mvx += joystickX / 80;
      mvz += joystickY / 80;
    }
    
    if (keys['w'] || keys['arrowup']) mvz -= 0.15;
    if (keys['s'] || keys['arrowdown']) mvz += 0.15;
    if (keys['a'] || keys['arrowleft']) mvx -= 0.15;
    if (keys['d'] || keys['arrowright']) mvx += 0.15;

    // Check if player is moving
    isMoving = Math.abs(mvx) > 0.01 || Math.abs(mvz) > 0.01;

    // Apply movement
    player.position.x += mvx * dt * 10;
    player.position.z += mvz * dt * 10;

    // Update player rotation based on movement direction
    if (mvx !== 0 || mvz !== 0) {
      player.rotation.y = Math.atan2(mvx, mvz);
    }

    // ----- IMPROVED Vertical physics -----
    // Apply gravity
    velY += gravity * dt;
    player.position.y += velY * dt;

    // Check platform collision with improved system
    const collision = checkPlatformCollision();
    
    if (collision.onPlatform && player.position.y - (playerHeight / 2) <= collision.surfaceY + 0.1) {
      // Player is on a platform or ground - PERFECTLY POSITIONED
      player.position.y = collision.surfaceY + (playerHeight / 2);
      velY = 0;
      grounded = true;
      
      // Check if player touched the ground (not a platform)
      if (collision.surfaceY === 0) {
        gameActive = false;
        gameOverScreen.style.display = 'block';
      }
    } else {
      grounded = false;
    }

    // jump action
    const wantJump = jumpPressed || keys[' '];
    if (wantJump && grounded) {
      velY = jumpImpulse;
      grounded = false;
    }

    // Update player animations
    updatePlayerAnimation(now * 0.001, isMoving);

    // npc bob & slight animation
    npc.rotation.y = Math.sin(now * 0.0008) * 0.02;
    npc.position.x = 0;
    npc.position.z = -16;

    // mark rotation
    mark.rotation.y += 0.02;

    // Third-person camera
    const targetCameraPosition = new THREE.Vector3();
    targetCameraPosition.copy(player.position);
    
    const cameraOffset = new THREE.Vector3(
      -Math.sin(player.rotation.y) * cameraDistance,
      cameraHeight,
      -Math.cos(player.rotation.y) * cameraDistance
    );
    
    targetCameraPosition.add(cameraOffset);
    
    camera.position.lerp(targetCameraPosition, 0.1);
    camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);

    // check distance for interaction with npc
    const dx = player.position.x - npc.position.x;
    const dz = player.position.z - npc.position.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    if (dist <= interactionRadius && !inRange) {
      inRange = true;
      dialog.style.display = 'block';
    } else if (dist > interactionRadius && inRange) {
      inRange = false;
      dialog.style.display = 'none';
      speech.style.display = 'none';
    }

    // Render
    renderer.render(scene, camera);
  }
  
  // Enable shadows
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  // Set player position on the first platform
  player.position.copy(startPos);
  scene.add(player);
  
  animate(0);

  // Resize handling
  window.addEventListener('resize', () => {
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
  });

  </script>
</body>
</html>
